# C# - Simple Payroll Software
A beginning C# project from the book *Learn C# in One Day and Learn it Well* by Jamie Chan, pp. 129-148.

This book is an absolute MUST for those new to C#, especially those who are still relatively new to programming. I went through the book in about five days, continued to study some of the concepts in the following days, and learned a lot I did not know or fully appreciate beforehand. Before reading this book:
- I did not quite appreciate the difference between a field and a property ("One of the main reasons [a property is used to provide access to a private field] is that using properties gives us greater control over what rights other classes have when assessing these private fields" pp. 73)
- Similarly, C#'s idiom of auto-implemented properties (pp. 76)
- The use of the `ToString()` method in C# programs ("a special method that returns a string that represents the current class" pp. 80)
- That a `static` (non-instantiated) qualifier applies to methods, fields, properties, constructors, and classes; a static class can only contain static members, but a non-static class may contain both static and non-static members, of which the static members do not need to be accessed via an object and it should be noted that *the member will remain the same across all instances of that class*. An example of a static class is `Console`. [Here](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/static-classes-and-static-class-members) is some more detail information abou static classes and members.
- The `params` keyword: used when "we do not know the number of arguments a method has" (pp. 89), e.g. `public void PrintNames(params string[] names) { /* for loop goes through some number of names */ }`.
- The value of a reference type parameter persists beyond a method, while any change to a value type parameter is only valid within the method itself (pp. 91-93).
- The two ways to create a child constructor: first, to simply declare it like any other constructor; second, to declare a child constructor using the colon sign and the `base` keyword to call a *non-parameterless* constructor in the parent class (pp. 97).
- Polymorphism: "refers to a program's ability to use the correct method for an object based on its *run-time type*" (pp. 102, emphasis mine). The base/parent class uses `virtual` to define the method while the derived/child class used the `override` keyword to indicate it's inherited from the `virtual` method. Basically, C# can determine the run-time type (the child class) even though the object may be declared as an instance of the parent class. Contrast declared type vs. run-time type. See pages 102-105.
- Use of `GetType()` and `typeof()`: briefly, `GetType()` returns the runtime type of an object, whereas `typeof()` takes the name of a data type and returns the type of that name which can then be compared to result of `GetType()` (pp. 105).
- C# allows users to define parent and child classes generally, but more specialized applications of the parent class are the abstract class and interface. "An abstract class is a special type of class that is created strictly to be a base class for other classes to derive from. They cannot be instantiated" (pp. 106). Interfaces are similar to abstract classes (cannot be instantiated and must be inherited), however, they are more "conceptual". First, they cannot have methods with bodies. Second, they can contain properties, but not fields. Third, they cannot have static members. A class that inherits an interface is said to "implement" the interface. Lastly, a class can inherit only one abstract class but can implement multiple interfaces. See pages 106-110 for more info.
- Access modifiers `private`, `protected`, and `public` and relationship to inheritance in the case of `protected` (pp. 113).
- The fact that `enum` enables "programmers to provide meaningful names for a set of *integral constants*" (pp. 114, emphasis mine). You can have an integer value that is then cast to the enum type, to get the associated name for that value.
- `struct` is a data type with many similarities to a class. A struct contains properties, constructors, methods, and fields; however, a struct differs from a class in that it doesn't support inheritance (but it can implement an interface) and is a value type.
- Learned about LINQ and assigning the elements of a list or array to a `var` LINQ object using the `new` keyword
- I did not know anything really about file handling in C# before reading this book. The most important bits of knowledge are: 1) we use `StreamReader`, `StreamWriter`, and `File` classes to work with files, which fall under the `System.IO` namespace; 2) the `using` keyword in this context ensures that the `Dispose()` method is always called, which in turn closes or releases any unmanaged resources such as files and streams once they are no longer needed (pp. 123-124 for example); 3) `File.Exists()` checks whether a file exists in a given directory; 4) using the `Close()` method to close a file; and, 5) use `StreamReader.ReadLine()` to read info from a file, `StreamWriter.WriteLine()` to write info to a file.
- Last but not least, the `try... catch` construct, which I wasn't totally familiar with (pp. 124-125)

The most valuable knowledge from this book was the succinct overview of object-oriented programming. I feel that I now have the knowledge to design programs and software with lower coupling and higher cohesion. Following this, I appreciated the information about LINQ, enums and structs, and file handling. The information at the beginning of the book was a good review for me as I had forgotten some of the particulars about data types, etc. in C#.

The project itself was a well-rounded application of all the most important ideas in the book - I especially appreciated implementing inherited classes. The first time I went through the instructions for the program, it did not quite work. Between trying to debug myself and referencing some parts of his answer code, I was able to get the programming up and running. All in all, it took me about three, maybe four, hours. I think I may try to implement again, without referencing the answer code, to see how I do; and then again, with perhaps a sketch of the requirements, to see if I can recreate the functionality myself. 
